% \iffalse
%% Source File: textcase.dtx
%% Copyright 2015 David Carlisle
%%
%% This file may be distributed under the terms of the LPPL.
%% See README for details.
%
%<*dtx>
          \ProvidesFile{luaregisternames.dtx}
%</dtx>
%<package>\NeedsTeXFormat{LaTeX2e}
%<package>\ProvidesPackage{luaregisternames}
%<driver> \ProvidesFile{luaregisternames.drv}
% \fi
%         \ProvidesFile{luaregisternames.dtx}
       [2015/06/24 v0.01 luaregisternames for luaLaTeX  (DPC)]
%
% \iffalse
%<*driver>
\documentclass{ltxdoc}
\ifx\directlua\undefined\else
\usepackage{luaregisternames}
\fi
\begin{document}
\DocInput{luaregisternames.dtx}
\end{document}
%</driver>
% \fi
%
% \GetFileInfo{luaregisternames.dtx}
%
% \title{The \textsf{luaregisternames} Package\thanks{This file
%        has version number \fileversion, last
%        revised \filedate.
% Please report any issues at https://github.com/davidcarlisle/dpctex/issues}}
% \author{David Carlisle}
% \maketitle
%
% \section{Introduction}
% Sometimes (notably in the case of lua attributes) it is necessary to
% access a register \emph{by number} that has been allocated by \TeX.
% This package provides a function to look up the relevant number
% using luatex's internal tables.
% 
% so after |\newluatexattribute\myattrib|
%
% If |\myattrib| has been defined by (say)
% |luatexattributedef\myattrib=15| then the lua function call
% |registernumber("myattrib")| will return 15. If the string passed as
% argument does not correspond to a token defined by
% |luatexattributedef|, |\countdef| or similar commands, the lua value
% |false| is returned.
%
%
% \section{Implementation}
%
% Note that the current implementation uses |\directlua| and a
%
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
% Stop if not lua\TeX.
%    \begin{macrocode}
\ifx\directlua\@undefined
\PackageError{luaregisternames}
{\luaregisternames may only be used with luatex}
{skipping package}
\expandafter\endinput
\fi
%    \end{macrocode}
%
%
% We need a declared register of each type, preferably 0.
% the \LaTeX\ format has predeclared registers for everything except
% lua attributes and muskip.
%    \begin{macrocode}
\luatexattributedef\reserved@a=0
\muskipdef\reserved@b=0
%    \end{macrocode}
%
% Test  the luatex version 0.80 is the texlive 2015 release.
%    \begin{macrocode}
\ifnum\luatexversion>79
%    \end{macrocode}
%
% This package only defines lua functions, no TeX code.
% (it might be better to distribute it as a lua file to be used with
% |require|. We'll see\ldots.
%    \begin{macrocode}
\directlua {
%    \end{macrocode}
%
% The |.mode| field in |newtoken| isn't currently documented but Hans
% Hagen pointed it out this possibility to me on the luatex list as a
% better alternative to the |hashtokens| below.
%
% First store the starting value of each register type in the internal
% command tables.
%    \begin{macrocode}
luaregisterbasetable={}
luaregisterbasetable["assign_glue"]=newtoken.create("skip@").mode
luaregisterbasetable["assign_mu_glue"]=newtoken.create("reserved@b").mode
luaregisterbasetable["assign_dimen"]=newtoken.create("dimen@").mode
luaregisterbasetable["assign_toks"]=newtoken.create("toks@").mode
luaregisterbasetable["assign_int"]=newtoken.create("c@page").mode
luaregisterbasetable["assign_attr"]=newtoken.create("reserved@a").mode
luaregisterbasetable["math_given"]=newtoken.create("@m").mode - 1000
luaregisterbasetable["char_given"]=newtoken.create("@inputcheck").mode
%    \end{macrocode}
%
% Now a function that determines the command type of a supplies csname
% and if it is one of the above types, return the relevant number,
% otherwise return |false|.
%    \begin{macrocode}
function registernumber (name) 
  local nt = newtoken.create(name)
  if(luaregisterbasetable[nt.cmdname]) then
    return nt.mode - luaregisterbasetable[nt.cmdname]
  else
    return false
  end
end
%    \end{macrocode}
% 
%    \begin{macrocode}
}
%    \end{macrocode}
% 
%    \begin{macrocode}
\else
%    \end{macrocode}
%
% Prior to 0.80 lua\TeX\ did not have athe |newtoken| class, however
% equivalent information could be obtained by peeking into the table
% returned by |hashtokens|.
% 
%    \begin{macrocode}
\directlua {
%    \end{macrocode}
%
%    \begin{macrocode}
luaregisterbasetable={}
luaregisterbasetable[tex.hashtokens()["skip@"][1]]=tex.hashtokens()["skip@"][2]
luaregisterbasetable[tex.hashtokens()["reserved@b"][1]]=tex.hashtokens()["reserved@b"][2]
luaregisterbasetable[tex.hashtokens()["dimen@"][1]]=tex.hashtokens()["dimen@"][2]
luaregisterbasetable[tex.hashtokens()["toks@"][1]]=tex.hashtokens()["toks@"][2]
luaregisterbasetable[tex.hashtokens()["c@page"][1]]=tex.hashtokens()["c@page"][2]
luaregisterbasetable[tex.hashtokens()["reserved@a"][1]]=tex.hashtokens()["reserved@a"][2]
luaregisterbasetable[tex.hashtokens()["@m"][1]]=tex.hashtokens()["@m"][2] - 1000
luaregisterbasetable[tex.hashtokens()["@inputcheck"][1]]=tex.hashtokens()["@inputcheck"][2]
%    \end{macrocode}
% 
%    \begin{macrocode}
function registernumber (name) 
  local nt = tex.hashtokens()[name]
  if(nt and luaregisterbasetable[nt[1]]) then
    return nt[2] - luaregisterbasetable[nt[1]]
  else
    return false
  end
end
%    \end{macrocode}
% 
%    \begin{macrocode}
}
%    \end{macrocode}
% 
%    \begin{macrocode}
\fi
%    \end{macrocode}
% 
% Just undo the two temporary definitions made at the start.
%    \begin{macrocode}
\let\reserved@a\relax
\let\reserved@b\relax
%    \end{macrocode}
% 
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \Finale
%
